/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package exercice

import kotlin.math.min

fun main() {
    val n = readLine()!!.toInt()
    val shortcuts = readLine()!!.split(' ').map { it.toInt() }
    val costs = computeCost(n, shortcuts.toIntArray())
    println(costs.joinToString(" "))
}

fun computeCostV2(n: Int, shortcuts: IntArray): IntArray {
    val cost = IntArray(n) { -1 }
    val q = ArrayDeque<Int>()
    cost[0] = 0
    q.add(0)
    while (q.isNotEmpty()) {
        val i = q.removeFirst()
        if (cost[shortcuts[i] - 1] == -1) {
            cost[shortcuts[i] - 1] = cost[i] + 1
            q.add(shortcuts[i] - 1)
        }
        if (i + 1 < n && cost[i + 1] == -1) {
            cost[i + 1] = cost[i] + 1
            q.add(i + 1)
        }
        if (i - 1 >= 0 && cost[i - 1] == -1) {
            cost[i - 1] = cost[i] + 1
            q.add(i - 1)
        }
    }

    return cost
}

fun computeCost(n: Int, shortcuts: IntArray): IntArray {
    val cost = IntArray(n) { n + 1 }
    var shortcutOrigin = 0
    var shortcutTarget = shortcuts[shortcutOrigin] - 1 // target is now 0-indexed, from 1-indexed
    cost[0] = 0
    var i = 1
    while (i < n) {
        // handles case shortcutTarget == i and initial cases where 0 shortcuts to 0.
        if (shortcutTarget <= i) {
            cost[i] = min(
                cost[i - 1] + 1,
                cost[shortcutOrigin] + 1 + i - shortcutTarget
            )
            // find first origin of next target. At worst, i + 1.
            shortcutOrigin += 1
            while (shortcutOrigin < n && shortcuts[shortcutOrigin] - 1 <= i) shortcutOrigin += 1
            if (shortcutOrigin == n) // implies i + 1 == n, so we're at the end
                return cost

            // find the origin minimizing the cost going downwards.
            var j = shortcutOrigin + 1
            while (j <= i) {
                if ((shortcuts[j] - i + cost[j]) < (shortcuts[shortcutOrigin] - i + cost[shortcutOrigin])) shortcutOrigin =
                    j
                j++
            }
            shortcutTarget = shortcuts[shortcutOrigin] - 1 // 1-indexed -> 0-indexed
        } else {
            cost[i] = min(
                cost[i - 1] + 1,
                cost[shortcutOrigin] + 1 + shortcutTarget - i
            )
        }
        i++
    }
    return cost
}
